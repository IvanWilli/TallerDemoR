[["index.html", "Taller de R aplicado a la Demografía 1 Introducción 1.1 Información general 1.2 PrepaRándonos 1.3 Presentación inicial", " Taller de R aplicado a la Demografía Ayelén Martinez, Florencia Bathory e Iván Williams 2023-12-05 1 Introducción 1.1 Información general ¡Bienvenid@s! Este sitio web contiene los materiales para el taller ofrecido en la Universidad Nacional de Luján, bajo el programa de maestría y especialización en Demografía Social, durante noviembre y diciembre de 2023. No es una guía autoexplicada, sino un acompañamiento y soporte para la cursada. Algunas cosas útiles: El programa actualizado se puede encontrar aquí. Encuentra el código fuente de este sitio en GitHub. Los datos que utilizaremos se pueden encontrar en un drive. Los encuentros virtuales los haremos vía zoom en este link. Ten en cuenta que esta página puede cambiar durante el curso, así que no te preocupes si notas algunos cambios. Podemos adaptar el contenido en función de la interacción que vayamos teniendo o corregir/agregar código a lo largo del camino. Esperamos que disfrutes el taller y te sea útil. Ayelén, Florencia e Iván 1.2 PrepaRándonos Pronto comenzaremos el Taller de R aplicado a la Demografía. El objetivo es que puedas dar tus primeros pasos en la herramienta y puedas aplicar allí las principales técnicas de la demografía. Esta edición del taller (tercera en su historia) la realizaremos un poco presencial (primer y último encuentro al menos) y un poco virtual. Para nuestro primer día sería bueno llevar lista tu compu en lo que atañe a la instalación del programa, de los paquetes y otras cuestiones mínimas, que si bien vamos a poder ayudarte in situ, nos ahorraría tiempo para comenzar con los materiales. Te proponemos tomarte unos minutos para que podamos arrancar sin problemas la primera clase. No te frustres si algo no funciona, podés contactárnos para ir solucionándolo, o en última instancia lo vemos en el primer encuentro. 1.2.1 Instalación de y RStudio Si estuviéramos en un auto, R es el motor, el sistema de dirección y frenos, y RStudio es nuestra interfaz: volante, pedales y los botoncitos que tocamos en los paneles (por ejemplo para poner ASPEN en la radio y disfrutar del viaje). Necesitamos instalar ambos y en su última versión disponible. Para esto debés ingresar a la página de descarga de R , e ir al instalador según el sistema operativo que utilices, la versión escritorio (desktop). Ejecuta el .exe y sigue los pasos. Como chequeo, la última versión es la 4.3.1. Luego debes ir a la web de RStudio y repetir el proceso previo. Un video muy ilustrativo del proceso de instalación es este1. Para aquellos que ya tienen R instalado pero de una versión previa, pueden volver a instalarlo siguiendo los pasos previos, que RStudio tomará de inmediato la más reciente cuando inicie una nueva sesión. O también pueden utilizar el paquete installr para los que ya vienen más habitué (sí, existe). 1.2.2 Instalación de paquetes Los paquetes (packages en inglés) son repositorios de código que contienen funciones relacionadas. Cada paquete tiene un tema al que se dedica, y dentro de éste, un objetivo o múltiples, siempre interrelacionados. A lo largo del taller utilizaremos muchos, por eso sería deseable que tengas instalados previamente algunos, ya que el éxito en parte depende de que la conexión a internet funcione bien. Abrí RStudio y en la consola pega el siguiente código, luego ejecutalo. Te arrojará un montón de mensajes sobre el proceso de instalación pero el último deberá darte un ok. install.packages(c(&quot;tidyverse&quot;, &quot;devtools&quot;, &quot;foreign&quot;, &quot;eph&quot;, &quot;plotly&quot;, &quot;gapminder&quot;, &quot;gridExtra&quot;, &quot;wpp2019&quot;, &quot;HMDHFDplus&quot;,&quot;rgdal&quot;,&quot;spdplyr&quot;,&quot;leaflet&quot;)) 1.2.3 Foro Para comunicarnos durante la semana utilizaremos el apartado de issues del repositorio en github, que permite escribir propuestas/sugerencias incluyendo pedazos de código (el lenguaje es markdown, que veremos en la última unidad). Para esto debes crearte un usuario. El uso de este espacio es opcional: si bien será útil para discutir contenido en la semana, si hay comunicaciones importantes de tipo administrativo se harán por mail. 1.2.4 Por último Si estás sin tiempo, lo prioritario es la instalación previa de R y RStudio. Cualquier cosa nos podés contactar por mail: Iván Williams: act.ivanwilliams@gmail.com Ayelén Martinez: ayemartinezn@gmail.com Florencia Bathory: florencia.bathory@gmail.com Nos vemos pronto! include_graphics(&quot;figs/programming.gif&quot;) 1.3 Presentación inicial Como introducción, charlaremos en base a los slides de aquí. A lo largo de este taller nos valdremos de contenido realizado por muuuchas personas. Una práctica que nos gustaría contagiarte: si nos aporta, démosle like y/o compartamos y/o dejémos algún feedback si es posible↩︎ "],["intro.html", "2 R Base 2.1 El proyecto Taller 2.2 Vectores 2.3 Data.frames 2.4 Listas 2.5 Referencias y materiales adicionales", " 2 R Base 2.1 El proyecto Taller Un proyecto es el marco en el cual realizás tu investigación o trabajo. Contiene los insumos, procesos y resultados. Empecemos por crear uno desde el menú: File/New Project, seleccionando el directorio de trabajo. Allí encontrarás un archivo con extensión R.proj. Creemos la carpeta de esta unidad, y también un script (File/New File/R Script) de extensión “.R”, que llamemos Unidad1.R, en el que seguiremos los contenidos y resolveremos los ejercicios. Para conocer “donde estamos parados”, nuestro directorio de trabajo (working directory) se encuentra por default en la carpeta del proyecto: getwd() 2.1.1 Variables Para adentrarnos en las características de R, censaremos un hogar. Pero… ¿qué es un hogar? Es una unidad de análisis demográfica, definida en un marco operativo censal: “se entiende por hogar una persona que vive sola o un grupo de personas que pueden o no estar emparentadas pero que comparten el presupuesto para los gastos de alimentación” (ONU, 2011) (ojo, no confundir con vivienda y/o familia). Resulta que nos fue asignada determinada vivienda, con un solo hogar. Al llegar a la cuadra vemos lo siguiente… Figure 2.1: Fuente: https://www.economist.com/books-and-arts/2020/04/16/a-lively-and-enlightening-history-of-the-census Por suerte nos fue asignada la siguiente vivienda. Son 6 miembros. ¿Cómo se listan los miembros de un hogar en un formulario censal? Figure 2.2: fuente: en base a https://www.indec.gob.ar/indec/web/Nivel3-Tema-2-41 Una vez completado el formulario persona para cada miembro, nos retiramos dando las gracias y nos sentamos a inspeccionar las características del hogar en R. Para esto empezaremos con los atributos del jefe o persona de referencia: Horacio . La asignación de variables (y de todo tipo de objeto) se realiza mediante el operador (veáse la direccionalidad objeto valor). edad &lt;- 63 Es recomendable no nombrar objetos con números al inicio, y sin incluir coma u otros caracteres especiales. También pueden encontrar el uso de = para asignar. ¿Qué usar? Para ver el contenido del objeto creado, podemos ejecutar su nombre en la consola, o desde el script pintando el objeto y presionando el botón Run (o ctrl+enter): edad ## [1] 63 Las operaciones lógicas estan por detrás de la mayoría de los procesos que realizaremos en el taller. ¿Es de equivalencia la siguiente relación? edad == 50 ## [1] FALSE ¿Es menor que…? edad &lt; 40 ## [1] FALSE Otras operaciones lógicas son: &gt;, &lt;=, &gt;=, != (distinto), etc. (luego veremos algunas más). Las operaciones sin asignación no cambian el valor de la variable creada: edad + 10 ## [1] 73 ¡Atención! lenguaje sensible a mayúsculas: Edad &lt;- 45 Edad != edad ## [1] TRUE Los tipos de variable más relevantes son: numeric (decimales con “.”) edad_exacta &lt;- 63.72 edad == trunc(edad_exacta) ## [1] TRUE character (string) nombre &lt;- &quot;Horacio&quot; # Qué clase de objeto es? (esto es un comentario en R) class(nombre) ## [1] &quot;character&quot; logic (verdadero/falso) autoRespondente &lt;- TRUE autoRespondente == FALSE ## [1] FALSE date (fecha) f_nacim &lt;- &quot;1960/01/01&quot; Mmm pero f_nacim es character (class(f_nacim)), por lo que deberíamos transformarlo. La función base para cambio de tipos comienza con as. Utilicemos el predictor de comando, a ver qué nos sugiere… (presiona “as.” para ver la lista desplegable de sugerencias). En este caso: f_nacim &lt;- as.Date(f_nacim) Fechas: si quisiéramos interpretar una fecha con el formato que utilizamos en Argentina, tendríamos que especificarlo: f_nacim &lt;- as.Date(\"01/01/1960\", format = \"%d/%m/%Y\").Por suerte hay paquetes como lubridate que nos harán las cosas más fáciles. Lo veremos en unidades siguientes. La ausencia de valor se representa con NA (missing/vacío): sexo &lt;- NA #un operador lógico importante es preguntar si un objeto es vacío: is.na(sexo) ## [1] TRUE Tu yo del futuro, otros humanos y múltiples computadoras leerán tu código: hablemos de algunas buenas practicas (aquí algunas). 2.1.2 Actividad El hogar que te fue asignado tambien tiene un jefe/a o persona de referencia. Te proponemos lo siguiente: Crear los atributos nombre, sexo, edad, f_nacim. El censo lo respondió otra persona. Asigna un valor a autoRespondente. Crear la variable edad_en_10_años que tenga la edad cumplida en 10 años. Corroborar que no son equivalentes. Obtener la diferencia entre ambas edades: edad_en_10_años - edad_hoy. 2.2 Vectores Es la estructura de datos más simple en R. Un vector es un arreglo de elementos del mismo tipo (podes comprobarlo). Inicializamos un vector combinando elementos mediante c(…). Por ejemplo c(1,2,3). Las variables son vectores de 1 elemento. Creemos los vectores de atributos de los miembros del hogar censado, cuyo orden refiere a cada unidad de análisis persona: nombre_jefe &lt;- &quot;Horacio&quot; nombre_conyuge &lt;- &quot;José&quot; nombre_hijos &lt;- c(&quot;Iván&quot;, &quot;Facundo&quot;, &quot;Cristian&quot;, &quot;Florencia&quot;) nombre &lt;- c(nombre_jefe, nombre_conyuge, nombre_hijos) # unión de vectores mediante c(), los &quot;apilo&quot; edad &lt;- c(63, 60, 35, 32, 27, 27) f_nacim &lt;- as.Date(c(&quot;1960/01/01&quot;, &quot;1961/11/05&quot;, &quot;1985/11/08&quot;, &quot;1987/01/21&quot;, &quot;1993/10/23&quot;, &quot;1993/10/24&quot;)) sexo &lt;- c(&quot;v&quot;, &quot;m&quot;, &quot;v&quot;, NA, &quot;v&quot;, &quot;m&quot;) autoRespondente &lt;- c(T, rep(F, 5)) # repetí un valor 5 veces # ¿Acabo de &quot;pisar&quot; objetos? ¿Qué significa? ¿Qué tipo de objetos son? ¿Qué información contienen? Algunas funciones útiles de exploración… class(f_nacim) # tipo de objeto ## [1] &quot;Date&quot; length(autoRespondente) # cantidad de elementos de un vector ## [1] 6 str(nombre) # estructura ## chr [1:6] &quot;Horacio&quot; &quot;José&quot; &quot;Iván&quot; &quot;Facundo&quot; &quot;Cristian&quot; &quot;Florencia&quot; summary(edad) # resumen de elementos ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 27.00 28.25 33.50 40.67 53.75 63.00 unique(sexo) # valores únicos ## [1] &quot;v&quot; &quot;m&quot; NA ¿Cómo extraer información de un vector? con […]. Por ejemplo, el nombre de la cuarta persona listada en mi hogar. nombre[4] ## [1] &quot;Facundo&quot; ¿Y de los tres últimos? Incluyo como referencia el vector de posiciones c(4,5,6). nombre[c(4,5,6)] ## [1] &quot;Facundo&quot; &quot;Cristian&quot; &quot;Florencia&quot; nombre[4:6] # equivalente ## [1] &quot;Facundo&quot; &quot;Cristian&quot; &quot;Florencia&quot; Un aspecto muuuy útil de R: vectorizar operaciones. Por default aplica la operación a cada uno de los elementos de un vector, sin necesidad de loopear a lo largo del mismo. Veamos qué pasa con los operadores lógicos que vimos en las variables: nombre == &quot;Facundo&quot; ## [1] FALSE FALSE FALSE TRUE FALSE FALSE ¿Qué personas tienen una edad menor a 33? edad &lt; 33 ## [1] FALSE FALSE FALSE TRUE TRUE TRUE ¡Pero decime los nombres che! nombre[edad &lt; 33] ## [1] &quot;Facundo&quot; &quot;Cristian&quot; &quot;Florencia&quot; Podemos comparar internamente elementos de un vector. ¿Qué estamos preguntando aquí? f_nacim[1] &lt; f_nacim ## [1] FALSE TRUE TRUE TRUE TRUE TRUE Más sobre extracción de elementos de un vector: ¿En qué orden fui listado yo?: which(nombre==\"Iván\") ¿Quiénes me caen bien? Puedo usar un operador lógico para excluir una posición (y dejar el resto). Todos menos Cristian: nombre[nombre!=\"Cristian\"] Otra forma de verlo, en dos pasos: posicion_de_Cristian &lt;- which(nombre==\"Cristian\") nombre[-posicion_de_Cristian] Medidas resúmen útiles sobre vectores numéricos: mean(edad) ## [1] 40.66667 min(f_nacim) ## [1] &quot;1960-01-01&quot; range(edad) ## [1] 27 63 Antes de continuar: si queremos reemplazar por ejemplo f_nacim por fecha_nacim, podemos utilizar lo que nos ofrece RStudio para buscar y reemplazar (con CRTL+f ) recreando el objeto desde el inicio, o crear un vector idéntico (y eliminar el anterior). fecha_nacim &lt;- f_nacim # remover (bienvenido si no quieres ir dejando basura pesada por allí) rm(f_nacim) Ayuda!!! Se puede pedir ayuda consultando la documentación de las funciones:?range o help(range). Y muy probablmente alguien ya se topó con tu problema: 2.2.1 Actividad Considerando el hogar de Horacio, responder: ¿Qué valores únicos tiene la variable autoRespondente? ¿Cuales son los nombres de las personas que censé con una edad mayor a 50? ¿En qué fecha nació Florencia? Toma 4 personas que conozcas e incorpóralos como miembros de tu hogar: crear los vectores de atributos nombre, sexo , edad y fecha de nacimiento de los miembros del hogar del grupo. Tener en cuenta el orden . ¿Cómo se llama la segunda persona listada? Obtener el nombre utilizando corchetes []. Obtener el rango de la edad de los miembros del hogar y su promedio. Para lo primero se puede usar min y max o directamente la función range. Mediante Sys.Date() se puede ontener la fecha de hoy (guardarla en una variable si es preferible). Calcular la edad exacta de los miembros, al día de la fecha, de la siguiente manera: (fecha_hoy - fecha_nacim)/365 (restamos fechas y las convertimos en años de manera aproximada). ¿Y la edad cumplida de los miembros cuál es? ¿El respondente informó correctamente la edad de todos los miembros? Con la función nchar() podés obtener el largo de un texto. ¿Cuál es el nombre más largo? 2.3 Data.frames El objeto más flexible en R es el data.frame: permite combinar múltiples variables de distintas clases, símil a las tablas que tratamos en otros softwares estadísticos o excel. Organicemos los atributos de los miembros de mi hogar en un data.frame: hogar &lt;- data.frame(nombre, sexo, edad, fecha_nacim, autoRespondente, stringsAsFactors = F) hogar ## nombre sexo edad fecha_nacim autoRespondente ## 1 Horacio v 63 1960-01-01 TRUE ## 2 José m 60 1961-11-05 FALSE ## 3 Iván v 35 1985-11-08 FALSE ## 4 Facundo &lt;NA&gt; 32 1987-01-21 FALSE ## 5 Cristian v 27 1993-10-23 FALSE ## 6 Florencia m 27 1993-10-24 FALSE ¿Características? class(hogar) # clase de objeto ## [1] &quot;data.frame&quot; str(hogar) # estructura ## &#39;data.frame&#39;: 6 obs. of 5 variables: ## $ nombre : chr &quot;Horacio&quot; &quot;José&quot; &quot;Iván&quot; &quot;Facundo&quot; ... ## $ sexo : chr &quot;v&quot; &quot;m&quot; &quot;v&quot; NA ... ## $ edad : num 63 60 35 32 27 27 ## $ fecha_nacim : Date, format: &quot;1960-01-01&quot; &quot;1961-11-05&quot; &quot;1985-11-08&quot; ... ## $ autoRespondente: logi TRUE FALSE FALSE FALSE FALSE FALSE summary(hogar) # resumen ## nombre sexo edad fecha_nacim autoRespondente ## Length:6 Length:6 Min. :27.00 Min. :1960-01-01 Mode :logical ## Class :character Class :character 1st Qu.:28.25 1st Qu.:1967-11-06 FALSE:5 ## Mode :character Mode :character Median :33.50 Median :1986-06-15 TRUE :1 ## Mean :40.67 Mean :1980-05-24 ## 3rd Qu.:53.75 3rd Qu.:1992-02-14 ## Max. :63.00 Max. :1993-10-24 colnames(hogar) # nombres de columnas ## [1] &quot;nombre&quot; &quot;sexo&quot; &quot;edad&quot; &quot;fecha_nacim&quot; &quot;autoRespondente&quot; ncol(hogar) # número de columnas ## [1] 5 nrow(hogar) # número de filas ## [1] 6 Para verlo tipo excel puedes usar View(hogar) o directamente desde el tab Environment haciendo click en el objeto. La selección de variables en un data.frame puede realizarse de distintas maneras. Por ejemplo para la variable sexo: # con &quot;$&quot;: al tipear el signo te sugiere las variables que contiene hogar$sexo ## [1] &quot;v&quot; &quot;m&quot; &quot;v&quot; NA &quot;v&quot; &quot;m&quot; # Una vez dentro del vector, vale lo que vimos en la sección previa de vectores. ¿Cuál es el miembro con sexo sin valor? hogar$nombre[is.na(hogar$sexo)] ## [1] &quot;Facundo&quot; También podemos seleccionar datos mediante coordendas del tipo [fila, columna], o condicionado a la variable elegida. hogar[2,3] # fila 2, columna 3 ## [1] 60 hogar$edad[2] # en la variable edad, seleccionar el segundo elemento ## [1] 60 hogar[2,] # ¿Y esto? ## nombre sexo edad fecha_nacim autoRespondente ## 2 José m 60 1961-11-05 FALSE hogar[,2] # ¿Y esto cuando lo vimos? ## [1] &quot;v&quot; &quot;m&quot; &quot;v&quot; NA &quot;v&quot; &quot;m&quot; Al crear el data.frame forzamos la no existencia de variables de tipo factor (stringsAsFactors = F). Los tipos de variable factor son variables categóricas (nominales u ordinales), con niveles (o códigos) y etiquetas (al estilo SPSS). Son muy relevantes para algunos paquetes que veremos más adelante, como ggplot2, para dar jerarquía al orden de visualización de las series. Por ejemplo, podemos crear la variable relación de parentezco rp respecto al jefe del hogar o persona de referencia. hogar$rp &lt;- factor(c(&quot;jefe&quot;, &quot;cónyuge&quot;, &quot;hije&quot;, &quot;hije&quot;, &quot;hije&quot;, &quot;hije&quot;)) # característica class(hogar$rp) ## [1] &quot;factor&quot; str(hogar$rp) # para R siempre la variable será esencialmente un entero ## Factor w/ 3 levels &quot;cónyuge&quot;,&quot;hije&quot;,..: 3 1 2 2 2 2 levels(hogar$rp) ## [1] &quot;cónyuge&quot; &quot;hije&quot; &quot;jefe&quot; nlevels(hogar$rp) ## [1] 3 Al parecer el respondente fue el cónyuge. Hagamos el cambio seleccionando de la variable autoRespondete aquellla observación (persona) que sea: hogar$autoRespondente[hogar$rp == &quot;jefe&quot;] &lt;- FALSE # ¿Cómo se lee esto? hogar$autoRespondente[hogar$rp == &quot;cónyuge&quot;] &lt;- TRUE 2.3.1 Actividad A partir de los vectores creados en la actividad previa, generar un data.frame con los miembros del hogar. Inspeccionar sus características. Obtener todos los datos del segundo miembro listado con el uso de corchetes []. Luego de una revisita al hogar encontramos que el tercer miembro listado prefiere que no conste su sexo, y que el cuarto miembro pefiere ser listado con su apodo “Pepe”. Hacer los cambios correspondientes. Agregar una variable con el número de caracteres de cada nombre. Informar el promedio. 2.4 Listas ¿Te preguntarás si hay vida más allá del data.frame? Por supuesto, las listas. Una lista es una colección de objetos de cualquier tipo (incluidos los data.frame). Por ejemplo si el tercer miembro es Iván y se construye en el terreno de los padres y forma su propio hogar dentro de la vivienda, el listado de hogares censado tendría dos data.frame: hogar_1 &lt;- hogar[-3,] hogar_2 &lt;- hogar[3,] lista_de_hogares &lt;- list(hogar_1 = hogar_1, hogar_2 = hogar_2) # inspecciono str(lista_de_hogares) ## List of 2 ## $ hogar_1:&#39;data.frame&#39;: 5 obs. of 6 variables: ## ..$ nombre : chr [1:5] &quot;Horacio&quot; &quot;José&quot; &quot;Facundo&quot; &quot;Cristian&quot; ... ## ..$ sexo : chr [1:5] &quot;v&quot; &quot;m&quot; NA &quot;v&quot; ... ## ..$ edad : num [1:5] 63 60 32 27 27 ## ..$ fecha_nacim : Date[1:5], format: &quot;1960-01-01&quot; &quot;1961-11-05&quot; &quot;1987-01-21&quot; ... ## ..$ autoRespondente: logi [1:5] FALSE TRUE FALSE FALSE FALSE ## ..$ rp : Factor w/ 3 levels &quot;cónyuge&quot;,&quot;hije&quot;,..: 3 1 2 2 2 ## $ hogar_2:&#39;data.frame&#39;: 1 obs. of 6 variables: ## ..$ nombre : chr &quot;Iván&quot; ## ..$ sexo : chr &quot;v&quot; ## ..$ edad : num 35 ## ..$ fecha_nacim : Date[1:1], format: &quot;1985-11-08&quot; ## ..$ autoRespondente: logi FALSE ## ..$ rp : Factor w/ 3 levels &quot;cónyuge&quot;,&quot;hije&quot;,..: 2 Para acceder a un elemento de la lista utilizamos doble corchete: # el primer hogar del listado es: lista_de_hogares[[1]] ## nombre sexo edad fecha_nacim autoRespondente rp ## 1 Horacio v 63 1960-01-01 FALSE jefe ## 2 José m 60 1961-11-05 TRUE cónyuge ## 4 Facundo &lt;NA&gt; 32 1987-01-21 FALSE hije ## 5 Cristian v 27 1993-10-23 FALSE hije ## 6 Florencia m 27 1993-10-24 FALSE hije # el nombre del miembro 3 del segundo hogar, mi antigua casa, ahora es: lista_de_hogares[[1]]$nombre[3] ## [1] &quot;Facundo&quot; # puedo utilizar también el nombre del objeto dentro de la lista, en vez de su posición: lista_de_hogares[[&quot;hogar_1&quot;]]$nombre[3] ## [1] &quot;Facundo&quot; Una buena explicación sobre la estructura de selección la dió el mismísimo Hadley Wickham acá. Estimados, considerando que no llego a fin de mes, decido incorporarme de nuevo a mi hogar natal, por lo que el hogar número 2 debe ser removido. ¿Cómo incorporo una nueva fila a un data.frame? Se puede utilizar rbind (r de rows, que tiene su primo cbind para unir columnas, con c de columns). # junto los hogares hogar_reunificado &lt;- rbind(hogar_1, hogar_2) # lo asigno de vuelta al hogar_natal original lista_de_hogares[[&quot;hogar_1&quot;]] &lt;- hogar_reunificado # borro de la lista el hogar independiente lista_de_hogares$hogar_2 &lt;- NULL Y debo tener el mismo hogar que antes, pero ahora como elemento de un listado: str(lista_de_hogares) ## List of 1 ## $ hogar_1:&#39;data.frame&#39;: 6 obs. of 6 variables: ## ..$ nombre : chr [1:6] &quot;Horacio&quot; &quot;José&quot; &quot;Facundo&quot; &quot;Cristian&quot; ... ## ..$ sexo : chr [1:6] &quot;v&quot; &quot;m&quot; NA &quot;v&quot; ... ## ..$ edad : num [1:6] 63 60 32 27 27 35 ## ..$ fecha_nacim : Date[1:6], format: &quot;1960-01-01&quot; &quot;1961-11-05&quot; &quot;1987-01-21&quot; ... ## ..$ autoRespondente: logi [1:6] FALSE TRUE FALSE FALSE FALSE FALSE ## ..$ rp : Factor w/ 3 levels &quot;cónyuge&quot;,&quot;hije&quot;,..: 3 1 2 2 2 2 2.4.1 Actividad Antes que cierres la puerta, el respondente te avisa que se alquila una pieza al fondo del terreno, donde vive Luis: varón, nacido el 3 de junio del 2000, en su hogar unipersonal. Incorporalo a la lista de hogares de al vivienda. hogar_luis &lt;- data.frame(nombre = &quot;Luis&quot;, sexo = &quot;v&quot;, edad = 23, fecha_nacim = &quot;2000-06-03&quot;, autoRespondente = TRUE, rp = &quot;jefe&quot;) Al querer irte Luis te avisa que en verdad el colabora monetariamente con la comida diaria, y hasta cenan juntos por las noches. Probablemente sea mejor unificar todo en un solo hogar. Hazlo recordando eliminar el hogar unipersonal de Luis asignando NULL a ese elemento de la lista, o en todo caso creando un nuevo objeto lista_de_hogares sin un segundo elemento (pisarlo). lista_de_hogares &lt;- list(hogar_1 = rbind(hogar, hogar_luis)) 2.5 Referencias y materiales adicionales Hoja de ayuda Libros en español "],["dplyr.html", "3 dplyr 3.1 Lectura de datos 3.2 dplyr", " 3 dplyr 3.1 Lectura de datos En la unidad previa caracterizamos un hogar censal. En esta unidad trabajaremos la base de datos censal, con todas sus viviendas, hogares y personas. Para esto recorreremos distintos paquetes de la familia tidyverse, cuyo fin es generar un entorno de herramientas especializada en el análisis de datos. # install.packages(&quot;tidyverse&quot;) library(&quot;tidyverse&quot;) library(fontawesome) library(knitr) Pero primero haremos un repaso por las distintas opciones de lectura de datos que nos ofrece R. Creemos una carpeta que se llame “Data”, donde dejemos las bases de datos disponibles en el drive. Verifiquemos que tengamos todas las bases de datos correspondientes en la carpeta “Data” mediante list.files(). list.files(&quot;Data&quot;) Para mostrar las diversas formas de lectura de datos que ofrece R nos valdremos de la Encuesta Permanente de Hogares (EPH), un operativo estadístico llevado adelante por INDEC con motivo de caracterizar la evolución de los mercados de trabajo de 31 aglomerados urbanos del país. Por ejemplo, si quisiéramos leer la base de datos del segundo trimestre de 2023, ¿qué opciones tenemos? ¿Qué opciones nos dan? Es muy importante aquí que la ruta del archivo a leer sea a partir de la posición de trabajo actual (recuerda getwd()) y hacia donde apuntar (puedes utilizar el predictor con tab luego de generar comillas). Texto plano con separador ; # R base trae funciones para la lectura de datos, las más comunes son &quot;read.table&quot; y &quot;read.csv&quot; EPH_2t23_txt &lt;- read.table(file = &quot;Data/usu_individual_T223.txt&quot;, header = T, sep = &quot;;&quot;) head(EPH_2t23_txt[,1:5]) Una planilla excel con extensión xls o xlsx, seleccionando la pestaña (y el rango de celdas si queremos). Aprovechemos a leer la documentación de esta función: ?read_xls o desde el tab de paquetes en RStudio. library(readxl) # pertenece a tidyverse EPH_2t23_xls &lt;- read_xlsx(path = &quot;Data/usu_individual_T223.xlsx&quot;, sheet = 1) head(EPH_2t23_xls) Nos interesa el rango “B3:C5”: read_xlsx(path = &quot;Data/usu_individual_T223.xlsx&quot;, sheet = 1, range = &quot;B3:C5&quot;, col_names = FALSE) También podemos leer extensiones .dbf, SAS, SPSS, Stata, etcéteras… gracias a la librería foreign. Por ejemplo, una base de datos del entorno SPSS de la EPH del primer trimestre de 2019: library(foreign) EPH_2t23_spss &lt;- read.spss(&quot;Data/usu_individual_T223.sav&quot;, to.data.frame=TRUE) En la primer unidad dijimos que un paquete es compartir , y es lo que hace a una comunidad dinámica. Ya existe un paquete llamado eph. Permite no solo leer las bases de datos trimestre a trimestre, sino funciones para obtener muchos resultados y panelear olas. ¿Qué warning nos da? library(eph) EPH_2t23_eph = get_microdata(year = 2023, trimester = 2, type = &#39;individual&#39;) 3.1.1 Acceso a archivos no locales También podemos leer un archivo online, por ejemplo la base de microdatos de DEIS (Dirección de Estadísticas e Información en Salud) de defunciones para los años 2005-2021. Vayamos a la web de Datos Argentina del Ministerio de Salud de la Nación, específicamente para Estadísticas Vitales, y veamos cómo obtener la dirección en la web con click derecho sobre el enlace. Tiene extensión .csv. Utilicemos la función read.csv comentada anteriormente, pero en vez de apuntar a un archivo local hagámoslo al url: url &lt;- &quot;http://datos.salud.gob.ar/dataset/27c588e8-43d0-411a-a40c-7ecc563c2c9f/resource/fab9e990-865c-43c4-a643-3dbc3b70a934/download/defunciones-ocurridas-y-registradas-en-la-republica-argentina-anos-2005-2021.csv&quot; DEf05_21 &lt;- read.csv(url, header = T) head(DEf05_21) Otras opciones posibles: Paquete con datos: por ejemplo wpp19 o wpp2022: estimaciones y proyecciones de Naciones Unidas, revisiones 2019 y 2022. ¿Qué diferencia encuentran entre la forma de acceder a los dos paquetes? Miles de datasets dispersos en muchos paquetes, aglutinados por CRAN, o por usuarios. Con conexión a un servidor: podemos acceder a una base de datos SQL Server, Oracle, etc. desde R, leyendo (y editando) sus tablas a partir de las credenciales que tengamos asignadas. Planillas de google: tenemos la posibilidad de leer y escribir planillas de cálculo en la nube. API: pedidos online de información a un tercero. Por ejemplo twitter (o X ahora), o servicios específicos como el de la OMS. 3.1.2 Actividad Seguro ya estas cansado de levantar datos: “Dame el censo” se escucha murmurar en el aula-zoom. Trabajaremos con una muestra aleatoria de viviendas del Censo 2010 en la Ciudad Autónoma de Buenos Aires. Los datos censales provienen de un proyecto de investigación expuesto en la conferencia AEPA17, y que tiene como objetivo traducir a microdato cualquier base con formato REDATAM, y cuyos resultados para el censo 2010 de Argentina pueden verse aquí. La base allí disponible NO es oficial, por lo que sus resultados pueden no ser los publicados, pero con motivo del taller nos permite jugar con las herramientas de manipulación de datos a nivel de máxima desagregación. Terminemos de afianzar lo visto hasta aquí. Te proponemos resolver/responder: Chequear que todas las versiones de la base de datos de la eph que leímos tengan la misma cantidad de observaciones (filas). ¿Cuántas muertes fueron registradas en el año 2021? ¿Cuantas de mujeres? ¿Cuántas en la provincia de Santa Fe? Si, necesitas un diccionario de datos, incluido en la web. Siguiendo con la base de defunciones, estimemos el impacto del exceso de mortalidad del año 2020 y el año 2021 (un número para cada año). Lo definiremos acá como el ratio entre las defunciones de 2020 (o 2021) respecto al promedio de los años 2017-2019. Leer “C2010_CABA_muestra.csv” (por deafult con separador “,”) y guardarlo en un objeto llamado caba2010_br (br por bruta, aún sin cambios). Explorar el objeto leído en el punto anterior con lo visto hasta quí, y resaltar aspectos que te llamen la atención. 3.2 dplyr En la unidad previa caracterizamos un hogar censal. En esta unidad trabajaremos la base de datos censal, con todas sus viviendas, hogares y personas. Para esto recorreremos algunos paquetes de tidyverse, cuyo fin es generar un entorno integrado de herramientas de análisis de datos. # install.packages(&quot;tidyverse&quot;) library(tidyverse) El paquete dplyr contiene las operaciones más comunes sobre una tabla de datos, y se volvió en los últimos años el paquete más utilizado para este fin. https://www.amazon.com/Dplyr-Hex-T-shirt-Rstudio-Tidyverse/dp/B07HKV9W7M Una de sus ventajas es el uso del pipe %&gt;%, que concatena operaciones sobre el mismo objeto, verbalizando el proceso, generando fluidez en nuestro razonamiento y mejor entendimiento para un tercero. En vez de f(x) (aplicar una función f() a un objeto x) se tiene x %&gt;% f() (tengo un objeto x y le aplico la función f()): 1:10 %&gt;% mean() Previo a comenzar debes haber leído la muestra censal de CABA “C2010_CABA_muestra.csv”, haberla inspeccionado brevemente y guardado en un objeto llamado caba2010_br (ver @ref{intro}). 3.2.1 seleccionar (select), renombrar (rename) Empecemos a trabajar la base de datos censal. Para este ejercicio nos interesa contar con la variable geográfica sobre el departamento de CABA al que pertence la vivienda, las variables de identificación de las unidades de análisis, y algunos atributos en función del cuestionario. Quedémonos con estas variables mediante la función select: caba2010 &lt;- select(.data = caba2010_br, IDDPTO, VIVIENDA_ID, HOGAR_ID, PERSONA_ID, V01, P01, P02, P03, P05) Podemos realizar la misma operación de la mano de %&gt;%, no necesitando especificar el objeto como argumento: caba2010 &lt;- caba2010_br %&gt;% select(IDDPTO, VIVIENDA_ID, V01, HOGAR_ID, PERSONA_ID, P01, P02, P03, P05) # léase: toma el objeto *** y selecciona las columnas *** Si quisiéramos quedarnos solo con las variables de persona podríamos usar starts_with(\"P\") dentro de select (o también PERSONA_ID:P05, ¡probalo!). Existen muuuchas más funcionalidades útiles para tablas con muchas columnas. Nótese que estamos pisando el mismo objeto. Luego podemos renombrar algunas variables para hacer su uso más fluido, mediante rename: # NuevoNombre = ViejoNombre caba2010 &lt;- caba2010 %&gt;% rename(Tipo_Viv = V01, Rel_Par = P01, Sexo = P02, Edad = P03, nativo = P05) # Tambien es posible por posición Habrás notado una de sus ventajas: la referencia al nombre de las variables no requiere $ ni “[,]” como en R Base. Podemos condensar lo anterior y hacerlo todo en un paso utilizando %&gt;%. Implica algo super útil: un nuevo %&gt;% supone el objeto ya modificado. caba2010 &lt;- caba2010_br %&gt;% rename(Tipo_Viv = V01, Rel_Par = P01, Sexo = P02, Edad = P03, nativo = P05) %&gt;% select(IDDPTO, VIVIENDA_ID, HOGAR_ID, PERSONA_ID, Tipo_Viv, Rel_Par, Sexo, Edad, nativo) ¿Lo que estamos generando es un data.frame? ¿Qué es un tibble? 3.2.2 Actividad Crear un data.frame llamado “caba2010_a” que contenga solo las variables identificatorias (que tienen un “ID”) de “caba2010_br”. Puedes utilizar la función contains (leer ejemplos). Renombrar las variables de manera que siempre comiencen con “ID_” (en vez de VIVIENDA_ID que sea ID_VIVIENDA). Contar la cantidad de columnas mediante ncol() y corrobar que la cantidad de variables sea menor a las de “caba2010_br”. 3.2.3 resumir (summarise) por grupos (group_by) Como analistas nos interesa calcular medidas resumen para poder obtener conclusiones, plantear hipótesis o simplemente conocer más el fenómeno relevado/registrado en los datos. Si quisiéramos saber cuántas personas existen en nuestra muestra de CABA podemos realizar un summarise (resumen) de los datos mediante la función n() (contar filas): n_personas &lt;- caba2010 %&gt;% summarise(casos = n()) Para contar cuántas viviendas fueron relevadas en la base debemos considerar casos con valor distinto en la variable de código de vivienda VIVIENDA_ID: n_viviendas &lt;- caba2010 %&gt;% summarise(casos = n_distinct(VIVIENDA_ID)) ¿Cuál es el promedio de personas por vivienda? Cóctel propio ¿De qué forma podríamos hacer lo anterior en R base (nrow,ncol,unique)? La experiencia de usuario de cada uno define el mix de herramientas que le es más cómodo/útil según la complejidad de cada tarea. Con summarise podemos aplicar cualquier función resumen sobre los datos. Por ejemplo: ¿Cuál es la edad promedio de las personas? ¿Cual es la edad máxima reportada? caba2010 %&gt;% summarise(edad_media = mean(Edad)) caba2010 %&gt;% summarise(edad_max = max(Edad)) ¿Podemos incluir todo lo anterior en una sola sentencia? ¡Esa es la magia de %&gt;%! caba2010 %&gt;% summarise(n_personas = n(), n_viviendas = n_distinct(VIVIENDA_ID), n_hogares = n_distinct(HOGAR_ID), pers_x_viv = n_personas/n_viviendas, pers_x_hog = n_personas/n_hogares, hog_x_viv = n_hogares/n_viviendas, edad_media = mean(Edad), edad_max = max(Edad) ) Las operaciones principales que podemos realizar mediante summarise las podés ver acá.Pero su utilidad se potencia cuando queremos resumir una variable segmentando por grupos. Esta agrupación antecede a summarise, y requiere ser indicada con group_by incluyendo como argumento las variables de agrupación. Por ejemplo, para conocer la cantidad de personas y viviendas relevadas por Departamento (Comuna): pers_viv_dpto &lt;- caba2010 %&gt;% group_by(IDDPTO) %&gt;% summarise(n_personas = n(), n_viviendas = n_distinct(VIVIENDA_ID)) Seguro estas cantidades difieren según código de tipo de vivienda. Pero primero podemos agregar la variable que describe los códigos. Carguemos como objeto el diccionario e incorporémoslo: cod_tipo_viv &lt;- data.frame(Tipo_Viv = 1:10, Tipo_Viv_descripc = c(&quot;Casa&quot;, &quot;Rancho&quot;, &quot;Casilla&quot;, &quot;Departamento&quot;, &quot;Pieza en inquilinato&quot;, &quot;Pieza en hotel familiar o pensión&quot;, &quot;Local no construido para habitación&quot;, &quot;Vivienda móvil&quot;, &quot;Persona/s viviendo en la calle&quot;, &quot;Sin Dato&quot;)) caba2010 &lt;- caba2010 %&gt;% left_join(cod_tipo_viv, by = &quot;Tipo_Viv&quot;) Joins!!! dplyr tiene las funciones típicas de join para el pareo de data.frames dependiendo la relación que desiemos. Ver más aquí. ¿Por qué hay valores NA en Tipo_Viv_descripc? Veamos qué código es el problemático creando una tabla de contingencia entre códigos y etiquetas: podemos usar la función count para descubrirlo: caba2010 %&gt;% count(Tipo_Viv, Tipo_Viv_descripc). Ahora sí, obtegamos el promedio de personas por vivienda según tipo: pers_tipoviv_dpto &lt;- caba2010 %&gt;% group_by(IDDPTO, Tipo_Viv_descripc) %&gt;% summarise(n_personas = n(), n_viviendas = n_distinct(VIVIENDA_ID), pers_viv = n_personas/n_viviendas) Parece una tabla muy grande (¿cuántas filas tiene?). Si querés mirar la tabla: View(tabla). 3.2.4 transformar (mutate), filtrar (filter), ordenar (arrange) Mediante mutate podemos crear variables nuevas que pueden o no relacionarse a las existentes. Tomando la tabla pers_viv_dpto (sin distinguir tipo de vivienda), podemos calcular el ratio de personas por vivienda segun departamento ratioPV: # a que base nos referimos head(pers_viv_dpto) # creo una variable (sin resumir como en summarise) pers_viv_dpto &lt;- pers_viv_dpto %&gt;% mutate(ratioPV = n_personas / n_viviendas) # Nos avisan desde INDEC que hay una hipótesis a corroborar de subenumeración de personas del 2% y de viviendas del 1%. Calculemos un indicador alternativo bajo esa hipótesis: pers_viv_dpto &lt;- pers_viv_dpto %&gt;% mutate(ratioPV_altern = n_personas * 1.02 / n_viviendas * 1.01) Para conocer qué departamentos poseen mayor promedio, podemos ordernar la tabla mediante arrange: pers_viv_dpto &lt;- pers_viv_dpto %&gt;% arrange(ratioPV) # mejor al revés: descendente pers_viv_dpto &lt;- pers_viv_dpto %&gt;% arrange(desc(ratioPV)) Si solo querés mostrar los tres departamentos con mayor valor, podés utilizar slice para seleccionar filas: pers_viv_dpto %&gt;% slice(1:3) %&gt;% select(IDDPTO, ratioPV, ratioPV_altern) ¿Tiene lógica esto? Comunas de CABA También puedes filtrar la base a un subconjunto del universo que cumpla determinadas condiciones utilizando filter. Por ejemplo, si quisiéramos conocer el indicador solo para las comunas al sur: comunas_al_sur &lt;- c(8,4) pers_viv_dpto %&gt;% filter(IDDPTO %in% comunas_al_sur) # Operador lógico! ¿te acordás? Vayamos hacia algo un poquito más complejo. Si quiero obtener la misma tabla anterior pero solo para viviendas que sean casas, casillas, ranchos o departamentos (códigos 1 a 4, viviendas individuales de mayor frecuencia), y que no sean hogares no unipersonales. Comencemos por crear el data.frame con ese listado: # busco un listado de hogares que cumplan ambas condiciones: hogares_NoUnipersonales &lt;- caba2010 %&gt;% filter(Tipo_Viv&lt;5) %&gt;% group_by(HOGAR_ID) %&gt;% summarise(n_personas = n()) %&gt;% filter(n_personas&gt;1) %&gt;% select(HOGAR_ID) # incluimos las tres unidades de análisis en una sentencia Ahora calculemos el indicador filtrando aquellos hogares obtenidos anteriormente. ¿Los resultados son razonables? PersVivNoUnip_Dpto &lt;- caba2010 %&gt;% filter(HOGAR_ID %in% hogares_NoUnipersonales$HOGAR_ID) %&gt;% group_by(IDDPTO) %&gt;% summarise(ratioPV = n() / n_distinct(VIVIENDA_ID)) %&gt;% arrange(desc(ratioPV)) %&gt;% slice(1:3) Si tuviéramos que relatar lo que estamos haciendo, sería algo del tipo: “toma CABA2010, filtralo, agrupalo y calcula por cada grupo el indicador (creando la variable); finalmente selecciona qué quieres mostrar”. Es una ¡composición de funciones!. Otra operación común es la de calcular distribuciones en una variable, segmentando con determinada agrupación. Podemos ver el porcentaje de mujeres dentro de cada departamento. Considerar que cualquier operación resumen (media, suma, contar) en un data.frame agrupado resumirá por grupos. Aprovechemos eso: Porc_mujeres &lt;- caba2010 %&gt;% group_by(IDDPTO, Sexo) %&gt;% summarise(N = n()) %&gt;% mutate(porcM = N/sum(N) * 100) %&gt;% # sum() es por grupos tambien! filter(Sexo == &quot;m&quot;) %&gt;% select(IDDPTO, porcM) En el caso de que querramos la distribución por grandes grupos de edad, podemos recodificar la edad con la función case_when en una nueva variable. distr_edadGG &lt;- caba2010 %&gt;% mutate(Edad_GG = case_when( Edad &lt; 15 ~ &quot;0-14&quot;, Edad &gt;= 15 &amp; Edad &lt; 65 ~ &quot;15-64&quot;, TRUE ~ &quot;65+&quot;)) %&gt;% group_by(IDDPTO, Edad_GG) %&gt;% summarise(N = n()) %&gt;% mutate(GG = N/sum(N)*100) %&gt;% select(IDDPTO, Edad_GG, GG) Otras opciones de recodificación son ifelse la opción base de R y recode. 3.2.5 Actividad Crea un nuevo objeto con el nombre que desees a partir de CABA2010_br renombrando las variables a tu gusto para que los nombres guarden relación con su contenido. Ordénala de la siguiente manera: ascendente ID de departamento, ascendente en ID de hogar, y decreciente en la edad. El hogar identificado como 613 no debería ser incluido en la base. Removerlo utilizando filter. Podrías encontrar las viviendas (sus ID) que poseen más de un hogar? ¿Cuántas son y qué porcentaje representa del total de viviendas? La variable nativo debería ser 0 (nativo) y 1 (no nativo). Sabiendo que en CABA había mas nativos que no nativos en 2010, inferir a que corresponde cada código y recodificar la variable manteniendo el tipo numerico/entero. Filtra por aquellas comunas costeras. Mediante la función mean obtén el promedio de edad de las comunas del punto anterior, mostrando el resultado según las más envejecidas primero. Realiza todo lo anterior en una sola sentencia. En una sola sentencia obtén la edad mediana por tipo de vivienda. ¿qué ves de interesante? Obten el promedio de edad de las personas mayores a 64 años cumplidos, según departamento y sexo. Puedes utilizar algo muuuy útil: filtros dentro del argumento de summarise: summarise(edad_media_65mas = mean(Edad[Edad&gt;64])). Identifica (toma el ID de) un hogar cualquiera con 5 miembros. 3.2.6 Recursos adicionales De Grande, Pablo (2016). El formato Redatam. Estudios demográficos y urbanos, 31, 3 (93) 811-832. r4ds. Una biblia que debés llevar bajo el brazo. dplyr: web del paquete. Hoja de ayuda (o “cheat sheet”). "],["ggplot.html", "4 ggplot 4.1 Introducción 4.2 ggplot 4.3 Lexis 4.4 Estudio de cohorte: un ejemplo 4.5 Reproduciendo 4.6 Otras visualizaciones 4.7 Material adicional (y no tanto)", " 4 ggplot 4.1 Introducción En esta sección vamos a explorar la utilidad de R para la visualización de contenido demográfico. En Riffe y otros (2021) se publicó una colección de artículos sobre ejemplos de “buena” visualización en este tema. Allí reseña un poco de la historia (ver los gráficos de Perozzo ) y se concluye con algunas recomendaciones a la hora de pensar cómo mostrar lo que queremos comunicar. Es interesante la distinción entre gráfico exploratorio y gráfico explicativo. En la unidad previa trabajamos con una muestra censal a nivel de registro. Aquí contaremos con una distribución por edad y sexo de la población censada en los dos últimos censos e iremos recorriendo distintas formas de visualizar su contenido. Tenemos un objetivo: Figure 4.1: https://fineartamerica.com/featured/walking-up-the-pyramid-kirt-tisdale.html?product=shower-curtain 4.2 ggplot El paquete ggplot del entorno tidyverse tiene sus fundamentos en la gramática de gráficos (Wilkinson, 2005), entender que todo plot es una composición de elementos, más allá de su especificidad (dispersión de putnos, línea, torta, etc.). La idea es “generalizar” su construcción tal que un paquete no sea una colección de casos especiales, sino una forma particular de combinar elementos (capas). Ya lleva 10 años! Todo gráfico esta compuesto, jearárquicamente, por: Datos: lo que contiene (en un formato determinado) aquello que queremos visualizar. Se utilza el argumento data. Capas Estética determinada: ¿quién es “x”?, ¿quién es “y”?, tamaño (size), color (color) y forma (shape), entre otros. Para esto se utiliza la función aes (de aestethics en ingles), y permite mapear las columnas de la data a cada argumento. Expresión geométrica de los datos. Las más comunes son: Puntos (geom_point) Líneas (geom_line) Barras (geom_bar) Transformación estadística (ajustar una regresión lineal, segmentar por percentiles, frecuencia de barra, etc.) Sistema de coordenas y Escalas: las medidas relativas con las cuales interpretar los datos y su transformación visual. Personalización de ejes y leyenda, cambiar a escala logarítmica, asignar una escala de colores, etc. Obtengamos la población censal por provincia de los dos últimos censos, disponible en el archivo “PoblCensal01y10.xlsx”. Seleccionemos CABA y veamos su distribución por edad en 2010 con ggplot. N_CABA &lt;- N_Censo %&gt;% filter(PROV_NOMBRE == &quot;CIUDAD AUTONOMA DE BUENOS AIRES&quot; &amp; CENSO==2010) # genero un primer gráfico con los tres elementos básicos: ggplot(data = N_CABA, # data aes(x = EDAD, y = VARON)) + # estética geom_line() # geometría Lo bueno de &gt;%&gt; es que puedo verbalizar también aquí! N_CABA %&gt;% ggplot(aes(x = EDAD, y = VARON)) + geom_line() ggplot utiliza + en vez de %&gt;%. No es algo de lo que esté orgulloso su creador, pero tiene sus razones. Podemos compararla con otras provincias en 2010, como Formosa y Entre Ríos, distinguiéndolas por color (estética). Tomemos el caso de los varones. ¿Qué observaciones podemos hacer? # creo un vector con las seleccionadas, y filtro la base Provincias &lt;- c(&quot;FORMOSA&quot;, &quot;ENTRE RIOS&quot;, &quot;CIUDAD AUTONOMA DE BUENOS AIRES&quot;) # filtro data N_Provs &lt;- N_Censo %&gt;% filter(PROV_NOMBRE %in% Provincias, CENSO==2010) # genero un primer gráfico con los tres elementos básicos: ggplot(data = N_Provs, # data aes(x = EDAD, y = VARON, color = PROV_NOMBRE)) + # estética geom_line() # geometría Podemos adicionar otra capa geométrica de puntos distinguiendo por forma (atributo estético adicional). Ya estamos en 4 dimensiones. g_Provs &lt;- ggplot(data = N_Provs, aes(x= EDAD, y = MUJER, color = PROV_NOMBRE)) + geom_line() + geom_point(aes(shape = PROV_NOMBRE)) Acabamos de crear un objeto: ¿de qué tipo es?. Lo que se encuentra dentro de ggplot() vale para todas las capas, excepto se “pise”. Por ejemplo, da el mismo plot las siguientes dos sentencias: data %&gt;% ggplot(aes(x= EDAD, y = MUJER) + geom_line() que… data %&gt;% ggplot() + geom_line(aes(x= EDAD, y = MUJER)) Agreguemos un título, un subtítulo, modifiquemos el tamaño del punto, la posición y título de la leyenda, y especifiquemos las marcas en el eje x: g_Provs &lt;- g_Provs + # partimos del objeto anterior labs(title = &quot;Población de varones por edad. Año 2010&quot;, subtitle = &quot;Provincias seleccionadas&quot;, caption = &quot;Fuente: INDEC&quot;, x = &quot;Edad&quot;, y = &quot;Varones&quot;) + theme(legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;, legend.title = element_blank()) + scale_x_continuous(breaks = seq(0,100,10)) # ups! g_Provs Podemos definir una paleta de colores, cambiar la temática de fondo por una más simple y suavizar las series con algún modelo. Adicionalmente mediante ggsave podemos guardar el objeto como imágen en la extensión que se desee. mi_paleta &lt;- c(&quot;#000000&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;) # sistema Hexadecimal de colores g_Provs &lt;- g_Provs + scale_colour_manual(values = mi_paleta) + theme_bw() + geom_smooth(method = &#39;loess&#39;, span=.5) # podés jugar con span (0,1) ggsave(filename = &quot;g_Provs.pdf&quot;, plot = g_Provs) g_Provs Podés encontrar más colores y paletas prediseñadas, temáticas predefinidas o incluidas en paquetes como ggthemes, y formas de suavizar una serie continua (aquí utilizamos loess, por defecto, pero puede ser lm, de linear model). Para continuar nuestro camino hacia la pirámide de población con ggplot, conviene que Sexo sea una única variable con dos categorías (una variable de tipo factor). Una buena idea: siempre tratar con tidy data! Figure 4.2: https://github.com/allisonhorst/stats-illustrations Postulados: Cada columna es una variable. Cada fila es una realización/observación de la unidad de análisis. Cada celda es un valor observado, un dato. Para esto utlizaremos las funciones pivot (antiguamaente llamadas gather y spread, por si lo ves en la web). Leamos la hoja de ayuda (cheat sheet) de tidyr juntos, otro paquete del entorno tidyverse. Y quedémonos por el momento con Entre Ríos. N_ER &lt;- N_Provs %&gt;% pivot_longer(cols = c(VARON, MUJER), names_to = &quot;Sexo&quot;, values_to=&quot;N&quot;) %&gt;% mutate(Sexo = as.factor(Sexo)) %&gt;% filter(PROV_NOMBRE == &quot;ENTRE RIOS&quot;) %&gt;% select(-PROV_CODIGO) %&gt;% arrange(CENSO, Sexo, EDAD) head(N_ER) Tenemos nuestra tabla preparada, es el momento de pasar a una geometría de barras. Al momento de trabajar con barras, la estética fill equivale al atributo color de líneas o puntos. Podemos incluir el condicional de signo dentro de la definición de ejes (o de manera previa mediante mutate, como prefieras): Pir_ER &lt;- ggplot(data = N_ER, aes(x = EDAD, y = ifelse(Sexo == &quot;VARON&quot;, -N, N), fill = Sexo)) + geom_bar(stat = &quot;identity&quot;) # que ggplot no trate de contar cual histograma Pir_ER Ups! Hay que dar vuelta (flip) la pirámide. Podemos hacerle unos cambios adicionales de paso: fijar los límites horizontales y mostrar solo absolutos, incluir titulo, subtítulo y fuente, cambiar las etiquetas de ambos ejes, incluir un tema distinto y cambiar el color de las barras. Pir_ER &lt;- Pir_ER + coord_flip() + scale_y_continuous(labels = abs, limits = max(N_ER$N) * c(-1,1)) + scale_x_continuous(labels = seq(0,110,5), breaks = seq(0,110,5), limits=c(0, 110)) + labs(y = &quot;Población&quot;, x = &quot;Edad&quot;, title = &quot;Pirámide de población. Año 2010&quot;, subtitle = &quot;Entre Ríos&quot;, caption = &quot;Fuente: en base a INDEC&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;green&quot;)) + theme_bw() Pir_ER Probablemente querramos comparar provincias, para lo que podemos usar las opciones de faceting. Volvamos a utilizar el data.frame de 3 provincias, transformándolo primero a formato tidy: # formato tidy N_Provs &lt;- N_Provs %&gt;% pivot_longer(cols = c(VARON, MUJER), names_to = &quot;Sexo&quot;, values_to = &quot;N&quot;) # pirámide Pirs &lt;- N_Provs %&gt;% ggplot(aes(x = EDAD, y = ifelse(Sexo == &quot;VARON&quot;, -N, N), fill = Sexo)) + geom_bar(stat = &quot;identity&quot;) + coord_flip() + scale_y_continuous(labels = abs, limits = max(N_Provs$N) * c(-1,1)) + labs(y = &quot;Población&quot;, x = &quot;Edad&quot;) + labs(title = &quot;Pirámide de población. Año 2010&quot;, subtitle = &quot;Provincias seleccionadas&quot;, caption = &quot;Fuente: INDEC&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;green&quot;)) + theme_dark() + facet_grid(rows = vars(PROV_NOMBRE)) # o cols? Pirs Utilicé dos veces labs! Es posible porque ggplot funciona sumando elementos. ¿El gráfico nos permite inferir estadíos transicionales? Mmm… Deberíamos verlo en porcentajes. Todo en una sentencia: PirsPorc &lt;- N_Provs %&gt;% group_by(PROV_NOMBRE, Sexo) %&gt;% mutate(Np = round(N/sum(N)*100,2))%&gt;% ggplot() + aes(x = EDAD, y = ifelse(Sexo == &quot;VARON&quot;, -Np, Np), fill = Sexo) + geom_bar(stat = &quot;identity&quot;) + coord_flip() + scale_y_continuous(labels = abs) + labs(y = &quot;Porcentaje de población&quot;, x = &quot;Edad&quot;) + theme_bw() + scale_fill_manual(values =c(&quot;blue&quot;, &quot;gold&quot;))+ facet_grid(cols = vars(PROV_NOMBRE)) PirsPorc Finalmente, cuando necesites guardar el gráfico, por ejemplo como pdf: ggsave(plot = &quot;PirsPorc.pdf&quot;, filename = PirsPorc) ¡Ahora sí! Estamos en condiciones de percibir visualmente qué nos dice el stock por edad y sexo: envejecimiento, efecto migratorio, patrones de declaración censal de edad. ¿Qué más? Quizás si fuera un gráfico interactivo… Un bonus track utilzando plotly: #install.packages(&quot;plotly&quot;) library(plotly) PirsPorc_plotly &lt;- ggplotly(PirsPorc + aes(text = Np), tooltip= &quot;text&quot;) 4.2.1 Actividad Realizar un gráfico de línea con el índice de masculinidad por edad de la provincia que prefiera para el censo 2010. Ahora incluya ambos censos, cada uno con un color distinto. Hacer el mismo gráfico pero comparando 3 provincias. El primer autor te escribe para incluir el gráfico previo en una publicación. ¿Qué modificaciones le harías para dejarlo listo? Construir la pirámide de población del Total país, colocando ambos censos uno debajo del otro. Ahora el primer autor (incansable) te solicita que hagas el plot anterior pero por grupos quinquenales de edad. 4.3 Lexis Gráfico útil para representar la dinámica poblacional de ingreso y permanencia en un estadío demográfico según edad, tiempo calendario (o período) y año de nacimiento (o cohorte). Su aplicación más común es en mortalidad, pero es generalizable a la relación exposición~evento con múltiples usos. Los elementos principales de análisis son: Líneas de vida (45°) Segmentos horizontales y verticales Superficies Ejemplos de uso del diagrama utilizando R: Mortalidad por conflictos armados (replicable): Fuente: Alburez et. al (2019) Sobremortalidad masculina en Inglaterra y Gales (1841-2013): Fuente: Schöley &amp; Willekens (2017) Construyamos el diagrama básico del inicio. Para eso haremos uso del paquete LexisPlotR creado por Philipp Ottolinger (gracias Otto). Construyó un set de funciones basadas en ggplot que facilita la creación de diagramas haciéndolo un ejercicio intuitivo. # install.packages(&quot;devtools&quot;) # devtools::install_github(&quot;ottlngr/LexisPlotR&quot;) #¿Cómo no esta en CRAN? library(LexisPlotR) library(tidyverse) # creamos el objeto &quot;mylexis&quot;, definiendo el rango de sus ejes: los primeros 10 años de vida durante 2010-2019. Aquí podemos especificar un &quot;delta&quot; si es que nos interesan los grupos quinquenales. mylexis &lt;- lexis_grid(year_start = 2010, year_end = 2019, age_start = 0, age_end = 10) # pintamos la edad 2 mylexis &lt;- lexis_age(lg = mylexis, age = 2) # pintamos el año 2015, de gris en este caso. mylexis &lt;- lexis_year(lg = mylexis, year = 2015, fill = &quot;grey&quot;) # Ahora la cohorte 2015 mylexis &lt;- lexis_cohort(lg = mylexis, cohort = 2015) # Una línea de vida, ¡elemento fundamental del diagrama! mylexis &lt;- lexis_lifeline(lg = mylexis, birth = &quot;2001-09-23&quot;, lwd = 1, colour = &quot;pink&quot;) # Al ser un objeto ggplot, podemos incorporarle atributos, como el título mylexis &lt;- mylexis + labs(x=&quot;Año&quot;, y = &quot;Edad&quot;,title = &quot;Diagrama de Lexis. Elementos de análisis&quot;) # Para crear polígonos, el autor se basa en la geometría &quot;geom_polygon&quot;. Creamos un cuadrado. El orden de los datos es importante. Además podemos crear muchos polígonos al mismo tiempo señalando los grupos. square &lt;- data.frame(group = c(1, 1, 1, 1), x = c(&quot;2012-01-01&quot;, &quot;2012-01-01&quot;, &quot;2013-01-01&quot;, &quot;2013-01-01&quot;), y = c(4, 5, 5, 4)) mylexis &lt;- lexis_polygon(lg = mylexis, x = square$x, y = square$y, group = square$group) # Creamos el triángulo. ¿A qué refiere? triangle &lt;- data.frame(group = c(1, 1, 1), x = c(&quot;2017-01-01&quot;, &quot;2018-01-01&quot;, &quot;2018-01-01&quot;), y = c(6, 6, 7)) mylexis &lt;- lexis_polygon(lg = mylexis, x = triangle$x, y = triangle$y, group = triangle$group) # Imprimimos! mylexis Adicionalmente, si trabajamos con población donde la exposición puede ser truncada (por derecha o izquierda), podemos graficar líneas de vida que respeten ese comportamiento. Tambien podemos señalar con una cruz la ocurrencia del evento de salida que se estudia. # ingresa al estudio sobre deserción escolar en el año 2012 un niño/a nacido en el año 2005, abandonando el colegio a los 9 años de edad: mylexis &lt;- lexis_lifeline(lg = mylexis, birth = &quot;2005-09-23&quot;, entry = &quot;2012-06-11&quot;, exit = &quot;2015-02-27&quot;, lineends = T, colour = &quot;red&quot;) mylexis Pero atrás de esto esta ggplot! ggplot() + geom_segment(aes(x = 2011, y = 5, xend = 2015, yend = 9), color = &quot;red&quot;, size=1)+ # debería ir al final geom_point(aes(x=2015, y=9),shape=4,size=2,col=4)+ coord_equal() + scale_x_continuous(breaks=2010:2020, expand = c(0,0)) + scale_y_continuous(breaks=0:10, expand = c(0,0)) + geom_vline(xintercept = 2010:2020, color=&quot;grey&quot;, size=.15, alpha = 0.8) + geom_hline(yintercept = 0:10, color=&quot;grey&quot;, size=.15, alpha = 0.8) + geom_abline(intercept = seq(-2020, -2000, by=1), slope = 1, color=&quot;grey&quot;, size=.15, alpha = 0.8)+ labs(x=&quot;Año&quot;, y=&quot;Edad&quot;,title = &quot;Dieagrama de Lexis c/ ggplot&quot;)+ theme_minimal()+ theme(panel.grid.major = element_line(colour = NA), panel.grid.minor = element_line(colour = NA), plot.background = element_rect(fill = &quot;white&quot;, colour = &quot;transparent&quot;)) Para incluir triángulos y cuadriláteros se utiliza geom_polygon. Para dar superficie, de manera similar al gráfico Scholey &amp; Willekens (2017), se utiliza geom_tile. Para esto último un gran tutorial de Tim Riffe. 4.4 Estudio de cohorte: un ejemplo Construyamos una tabla de cohorte a partir de un grupo de estudiantes que iniciaron con 3 años de edad (cumplida) su trayectoria educativa el 3/3/2000, y donde la salida es dejar el estudio (sea cual sea el nivel alcanzado) por primera vez antes de retomar o abandonar definitivamente (¿en este contexto qué sería \\(\\omega\\)?). Simulemos el comportamiento de 1000 chicas/os con distribución uniforme de la edad y distribución gamma del tiempo de permanencia: set.seed(100) # qué es esto? clase &lt;- data.frame(edad_inicio = runif(n = 1000, min = 3, max = 4), tiempo_exp = rgamma(n = 1000, shape = 40, rate = 2)) %&gt;% mutate(edad_salida = edad_inicio + tiempo_exp) ¿Cómo luce? ggplot(clase, aes(x=edad_salida)) + geom_histogram(fill=2, alpha=.5) + labs(x = &quot;Edad de salida&quot;, y = &quot;Densidad&quot;, title = &quot;1000 casos simulados de edad de primer salida educativa&quot;) Construyamos el diagrama de Lexis de esta cohorte utilizando LexisPlotR: # una forma de moverse en el tiempo: a una fecha restarle cantidad de días clase$nacimiento &lt;- as.Date(&quot;2000-03-03&quot;) - clase$edad_inicio * 365.25 clase$salida &lt;- clase$nacimiento + clase$tiempo_exp * 365.25 # creo Lexis mylexis &lt;- lexis_grid(year_start = 2000, year_end = 2025, age_start = 3, age_end = 30) mylexis &lt;- lexis_lifeline(lg = mylexis, birth = clase$nacimiento, entry = &quot;2000-03-03&quot;, exit = clase$salida, lineends = T, colour = 4, alpha = 1/3) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) mylexis ¿Por qué las líneas no empiezan justo en 2000? Estimemos algunos parámetros básicos: # la edad media de salida mean(clase$edad_salida) # la probablidad de &quot;sobrevivir&quot; a la edad 18 clase %&gt;% filter(edad_salida &gt;= 18) %&gt;% summarise(n()/nrow(clase)) # probablidad de abandonar en los 20 años cumplidos clase %&gt;% filter(edad_salida &gt;= 20 &amp; edad_salida &lt; 21) %&gt;% summarise(n()/nrow(clase)) ## [1] 23.4662 ## n()/nrow(clase) ## 1 0.974 ## n()/nrow(clase) ## 1 0.103 4.4.1 Actividad Crear un diagrama de Lexis e incluir en rojo las líneas de vida de las 3 personas más jóvenes que conozcas. Considerando el ejercicio de permanencia escolar: Calcula la probabilidad de “salir” luego de los 30 años? Cambia la semilla del ejercicio previo (set.seed()) por cualquier entero que desees y repite el ejercicio. ¿Hay diferencias? ¿Por qué? 4.5 Reproduciendo El covid19 puso en primera plana el análisis demográfico, especialmente en el impacto que tuvo en \\(e_0\\) ¿No te parece genial la figura 1 del paper Quantifying impacts of the COVID-19 pandemic through life-expectancy losses: a population-level study of 29 countries de Aburto y Otros (2021)? Podemos recrearlo gracias a que los autores lo permiten aquí, haciendo su paper reproducible. De paso vamos viendo funciones nuevas. Iremos comentando los pasos: # necesitamos algunas librerías que no tenemos aún. Si no las tenés debes instalarlas primero #install.packages(&quot;hrbrthemes&quot;) library(hrbrthemes) # cargar la data df_ex_ci &lt;- read_rds(&quot;Data/df_ex_ci.rds&quot;) head(df_ex_ci) # crear el gráfico fig_1 &lt;- df_ex_ci %&gt;% # primero factorizar según el número actual de la variable mutate(name = name %&gt;% fct_reorder(rank_e0f19)) %&gt;% # me interesa ciertas edades filter(age %in% c(0, 60)) %&gt;% # si hay alguna NA sacar la fila drop_na(name) %&gt;% # una forma de seleccionar transmute(name, sex, age,ex_2015, ex_2019, ex_2020 = ex) %&gt;% # hete aquí un pivot... pivot_longer(cols = ex_2015:ex_2020, names_to = &quot;year&quot;, values_to = &quot;ex&quot;, names_prefix = &quot;ex_&quot;) %&gt;% mutate(age = age %&gt;% as_factor()) %&gt;% # ggplot ggplot()+ # un color por sexo, una forma por año geom_point(aes(x = ex, y = name, color = sex, shape = year))+ # separar un poco con líneas grises geom_hline(yintercept = seq(2, 28, 2), size = 5, color = &quot;#eaeaea&quot;)+ # personalizar qué formas, tamaños y colores usar scale_shape_manual(values = c(124, 43, 16))+ scale_size_manual(values = c(4, 4, 1.5))+ scale_color_manual(values = c(&quot;#B5223BFF&quot;, &quot;#64B6EEFF&quot;))+ # donde colocar los nombres de los ejes scale_y_discrete(position = &quot;right&quot;)+ scale_x_continuous(position = &quot;top&quot;)+ # facet por edad, sin respetar escala facet_grid(~age, scales = &quot;free_x&quot;)+ # sin leyenda, líneas horizonatales y demases theme( legend.position = &quot;none&quot;, panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank(), strip.text = element_blank(), panel.spacing.x = unit(2, &quot;lines&quot;), axis.text.y = element_text(face = 2))+ # etiquetas de ejes labs(x = &quot;Life expectancy, years&quot;,y = NULL) # guardar ggsave(fig_1, filename = &quot;fig-1.pdf&quot;, width = 6, height = 4.5, device = cairo_pdf) Las etiquetas en referencia a la edad y la formas de los puntos las realizaron posteriormente con annotate, una función que permite incluir (encima) texto u otras figuras geométricas en el plano. 4.6 Otras visualizaciones Samuel Preston (1975) encontró una relación matemática (al menos) a nivel de país entre la esperanza de vida al nacer y el producto per cápita. Veamos que ocurre específicamente en el Continente Americano utilizando el paquete de datos gapminder. library(gapminder) p &lt;- ggplot(filter(gapminder, continent == &quot;Americas&quot;), aes(x = gdpPercap, y = lifeExp)) p + geom_point() # dispersión p + geom_point(aes(color = country), alpha = (1/3), size = 3, show.legend = F) p1 &lt;- p + geom_point(aes(color = country, size = pop), alpha = 1/3) # fijate el lugar de size p1 &lt;- p1 + geom_smooth(lwd = 1, lty = 2, color = 2, se = FALSE) p1 p + geom_point(alpha = 1/3, size = 3) + facet_wrap(~ country) + geom_smooth(lwd = 1.5, se = FALSE) + theme_void() ¿Componer gráficos en una sola hoja? (tomado de Jenny Bryan) #install.packages(&quot;gridExtra&quot;) library(gridExtra) p2 &lt;- ggplot(filter(gapminder, year==1952 &amp; continent!=&quot;Oceania&quot;), aes(x = lifeExp, color = continent)) + geom_density() p3 &lt;- ggplot(filter(gapminder, year==2007 &amp; continent!=&quot;Oceania&quot;), aes(x = lifeExp, color = continent)) + geom_density() grid.arrange(p2, p3, nrow = 2, heights = c(0.5, 0.5)) ¿Qué problemas encuentras en este arreglo? 4.7 Material adicional (y no tanto) Sí, hay un libro. Estas notas fueron hechas siguiendo principalmente The Hitchhiker’s Guide to Ggplot2 y el curso de Jenny Bryan. Hoja de Ayuda. Hulíková Tesárková &amp; Kurtinová. Application of “Lexis” Diagram: Contemporary Approach to Demographic Visualization and Selected Examples of Software Applications. Rau, R., Bohk-Ewald, C., Muszyńska, M. M., &amp; Vaupel, J. W. (2018). Visualizing Mortality Dynamics in the Lexis Diagram. Springer. doi: 10.1007/978-3-319-64820-0 "],["funciones.html", "5 Funciones 5.1 DemogRafía 5.2 Funciones 5.3 Crecimiento 5.4 Estandarizando 5.5 Funciones demográficas en paquetes demográficos", " 5 Funciones 5.1 DemogRafía ¿Qué es la demografía? Algunas definiciones (tomado de Carmichael, 2016): Guillard (1855; citado en Shryock, Siegel and Associates, 1973): “la historia natural y social de la especie humana o el conocimiento matemático de las poblaciones, de sus cambios generales y de su condición física, civil, intelectual y moral”. Hauser y Duncan (1959): La demografía es el estudio del tamaño, la distribución territorial y la composición de la población, los cambios en la misma y los componentes de dichos cambios, que pueden identificarse como natalidad, mortalidad, movimiento territorial (migración) y movilidad social (cambio de estado). Weeks (1994): La demografía se refiere a prácticamente todo lo que influye, o puede ser influenciado por el tamaño de la población, su distribución, procesos, estructura o características de ella. Preston et. al, (2001): cambios en su tamaño, sus tasas de crecimiento y su composición. La demografía es uno de las disciplinas de las ciencias sociales donde los análisis a nivel micro y macro encuentran quizás su más completa y satisfactoria articulación. Palabras clave: especie + tamaño + composición + territorio + estado + cambio + micro/macro. 5.2 Funciones Una función consiste en encapsular un proceso, que recibe argumentos y devuelve un resultado. En general, si un bloque de código es copiado y pegado en más de una vez en un espacio de trabajo entonces merece su función. Las funciones en R contienen: un nombre argumentos (input) ¿Qué necesita? cuerpo (código que elabora una respuesta en función de argumentos) respuesta/resultado (output). ¿Qué devuelve? # se enuncia entre llaves nombre&lt;- function(argumentos) { código return(resultado) } Por ejemplo, si queremos tener una función que nos diga cuantos años cumplidos tendrá una persona de edad x en t años: edad_en_t_anios &lt;- function(x, t){ x_en_t_años &lt;- x + t # este valor solo existirá en este contexto (scoping) return(x_en_t_años) } # Juan tiene 35. ¿Cuantos tendrá en 10 años? edad_en_t_anios(35, 10) # no nombré los argumentos porque respeté el orden # Edades de un hogar en 5 años edades = c(59, 58, 32, 30, 25, 25) edad_en_t_anios(edades, 5) Las funciones pueden tener valores por defecto. Por ejemplo: edad_en_t_anios &lt;- function(x, t = 5){ x_en_t_años &lt;- x + t return(x_en_t_años) } edad_en_t_anios(x = 35) 5.3 Crecimiento Tenemos una población que en el año 2010 era de 50.000 personas y en 2020 era de 60.000. Nos preguntan cual sería la población a 2025. Existen distintas formas en que podemos modelar su crecimiento total a partir de dos puntos observados en el tiempo. En términos generales para un momento 0 y un momento t, debemos obtener primero el ritmo al que crece, es decir su tasa anual promedio: Supuesto \\(N(t)\\) \\(\\overline{r}(0,t)\\) Lineal \\(N(0) * (1+r*t)\\) \\([\\frac{N(t)}{N(0)}-1]/t\\) Exponencial \\(N(0) * e^{r * t}\\) \\(\\ln(\\frac{N(t)}{N(0)})/t\\) Construyamos una función para modelar su crecimiento y poder interpolar/extrapolar según el modelo lineal. Una función debe ser diseñada para ser aplicable a muchos casos específicos. Llamaremos h a la distancia desde la primera observación para la que deseamos obtener la nueva población. crecim_lineal &lt;- function(N0, Nt, t, h){ r &lt;- (Nt/N0-1)/t Nh &lt;- N0 * (1+r*h) return(Nh) } Nuestra respuesta a la pregunta inicial podría ser: # ¿qué población habrá en 2025? N2025 &lt;- crecim_lineal(N0 = 50000, Nt = 60000, t = 10, h = 15) # miremos un gráfico tibble(Año = c(2010, 2020, 2025), N = c(50000, 60000, N2025)) %&gt;% ggplot(aes(Año, N)) + geom_line() + geom_point() ¿Si quisiera tener opciones al momento de calcular el crecimiento? lineal o exponencial. Incluyamos el argumento tipo y utilicemos el condicional if para posicionarnos en el modelo que se quiera. crecim &lt;- function(N0, Nt, t, h, tipo = &quot;lineal&quot;){ # si se quiere el modelo exponencial if(tipo == &quot;exponencial&quot;){ r &lt;- log(Nt/N0)/t Nh &lt;- N0 * exp(r*h) } # si se quiere el modelo lineal if(tipo == &quot;lineal&quot;){ Nh &lt;- crecim_lineal(N0, Nt, t, h) # una función dentro de otra!!! } return(Nh) } Veamos que obtuvimos con las dos opciones: N2025 &lt;- data.frame(N2025_lineal = crecim(50000, 60000, 10, 15, tipo = &quot;lineal&quot;), N2025_exp = crecim(50000, 60000, 10, 15, tipo = &quot;exponencial&quot;)) data.frame(Año = c(2010, 2020, 2025, 2025), N = c(50000, 60000, N2025$N2025_lineal, N2025$N2025_exp), Tipo = c(&quot;Observado&quot;, &quot;Observado&quot;, &quot;lineal&quot;, &quot;exponencial&quot;)) %&gt;% ggplot(aes(Año, N)) + geom_point(aes(shape = Tipo, color=Tipo)) ¿Y si tuviéramos un vector de población por edad? Podemos tener una tasa \\(\\overline{r}(0,t)\\) por cada edad. # crecimiento por edad N2025_edad &lt;- data.frame(Edad = c(&quot;0-14&quot;, &quot;15-64&quot;, &quot;65+&quot;), N2010 = c(20000, 20000, 10000), N2020 = c(25000, 30000, 5000)) %&gt;% mutate(N2025_lineal = crecim(N2010, N2020, 10, 15, tipo = &quot;lineal&quot;), N2025_exp = crecim(N2010, N2020, 10, 15, tipo = &quot;exponencial&quot;)) N2025_edad %&gt;% pivot_longer(cols = !Edad, names_to = &quot;Tipo&quot;, values_to = &quot;N&quot;) %&gt;% ggplot(aes(Edad, N, fill = Tipo)) + geom_bar(stat = &quot;identity&quot;, # no trates de ser un histograma position = &quot;dodge&quot;) # posición lado a lado El poner a disposición de otros usuarios tus funciones requiere controlar los errores posibles, entre otras cosas por ingresar como argumentos objetos no esperados (por ejemplo, un objeto character en algunos de los primeros argumentos). Ejemplo: especifico que no acepto un objeto character como argumento en N0, Nt, t ni h: crecim_lineal_check &lt;- function(N0, Nt, t, h){ # check argumentos if(is.character(N0) | is.character(Nt) | is.character(t) | is.character(h)){ stop(&quot;Ingresaste un texto en algún argumento&quot;) } # función previa r &lt;- (Nt/N0-1)/t Nh &lt;- N0 * (1+r*h) return(Nh) } crecim_lineal_check(50000, 60000, 10, &quot;hola&quot;) 5.3.1 Actividad Siguiendo el ejemplo previo: ¿cuál sería la población al 2017 bajo el supuesto de crecimiento exponencial? ¿Es equivalente interpolar cada edad y luego sumar? Crear una función que informe la edad modal de una distribución de conteo, por ejemplo para data.frame(Edad = c(0,4,7,10), Casos = c(2, 6, 9, 0)) debería devolver la edad 7. Obtener una función que permita conocer en cuantos años (h) se duplicará la población respecto al primer valor observado, bajo el supuesto de crecimiento lineal y exponencial. (Ayuda: obtén \\(r\\) y luego despeja \\(h\\) para que \\(N_h=N_0*2\\)). 5.4 Estandarizando Entre los intentos por discriminar el efecto de la estructura por edad en el indicador de Tasa Bruta de Mortalidad \\(TBM(t)=\\frac{D(t)}{N(t)}\\) (defunciones sobre población expuesta2) se encuentra el clásico método de estandarización (Swanson &amp; Siegel, 2004). En principio, la \\(TBM(t)\\) de una población puede ser expresada como el promedio ponderado de las tasas específicas de mortalidad \\(M_x(t)=\\frac{D_x(t)}{N_x(t)}\\) por el peso poblacional de cada edad \\(C_x(t)=\\frac{N_x(t)}{N(t)}\\): \\[ TBM(t) = \\frac{D(t)}{N(t)}= \\sum_{x&gt;=0}{M_x(t)\\,C_x(t)} \\] Poblaciones envejecidas tendrán una mayor frecuencia de muertes debido a la distribución de \\(C_x(t)\\), pero no reflejando su nivel. El proceso de estandarización reemplaza \\(C_x(t)\\) por otra distribución que permita la comparación entre distintas poblaciones: sería equivalente a asignarle una misma pirámide poblacional a ambas poblaciones. Si llamamos a esta distribución estándar tenemos \\(C^S_x(t)\\) y podemos calcular para dos poblaciones cualquiera \\(A\\) y \\(B\\) su Tasa Estandarizada de Mortalidad: \\[ TSM^A(t) = \\sum_{x&gt;=0}{M^A_x(t)\\,C^S_x(t)}\\\\ TSM^B(t) = \\sum_{x&gt;=0}{M^B_x(t)\\,C^S_x(t)}\\\\ \\] Lo que permite comparar \\(TSM^A(t)\\) con \\(TSM^B(t)\\): \\(TSM^A(t) \\lessgtr TSM^A(t)\\). Pero vayamos al ejemplo!!! Obtengamos la población y defunciones de Chile, Japón y Polonia del año 2000 y 2010 leyendo la tabla “Chile_Japon_Polonia.csv” en la carpeta “Data”. ¿Cómo obtuve esta información? Directamente desde R hacia el repositorio de la Human Mortality Database, utilizando el paquete HMDHFDplus. Por ejemplo en este caso las defunciones de Chile por grupos quinquenales de edad (en realidad se muestra la edad inicial de cada intervalo) cada 5 años calendario, “Deaths_5x5”, se pueden obtener con la función readHMDweb. db &lt;- readxl::read_xlsx(&quot;Data/Chile_Japon_Polonia.xlsx&quot;) Enfoquémonos en el 2010 para comparar los tres países. Japón presenta una \\(TBM\\) mayor pero atribuible a otro estadío en su envejecimiento según la porción de población de 65 años y más. db &lt;- db %&gt;% filter(Year == 2010) db %&gt;% group_by(Country) %&gt;% summarise(TBM = sum(D)/sum(N)*1000, porc_65_mas = sum(N[Age&gt;=65])/sum(N)) Y esto es visible en la jerarquía de las tasas de mortalidad por edad: # creamos la varibale con las tasas de mortalidad específicas db &lt;- db %&gt;% mutate(M = D/N) ggplot(db) + geom_step(aes(x=Age,y=M,color=Country))+ scale_y_log10()+ scale_x_continuous(breaks = seq(0,110,10), labels = seq(0,110,10)) + labs(caption = &quot;Human Mortality Database&quot;)+ theme_bw() Estandaricemos utilizando el promedio de la estructura por edad de los tres: C_x_promedio &lt;- db %&gt;% group_by(Age) %&gt;% summarise(c_x = sum(N)/sum(db$N)) db %&gt;% left_join(C_x_promedio) %&gt;% group_by(Country) %&gt;% summarise(TSM = sum(M * c_x)*1000) !Ahora sí! El indicador nos muestra un nivel de mortalidad para 2010 mayor en Polonia, seguido de Chile y Japón. Cabe aclarar que en este sentido el mejor indicador resumen es la esperanzada de vida (\\(e_x\\)), que se estima a partir de la construcción de una tabla de vida (Preston y otros, 2001). ¿Cómo sería una función que reciba una tabla con las variables País, N y D y devuelva las \\(TBM\\) y las \\(TSM\\)? 5.4.1 Actividades Responder la pregunta previa con los mismos datos utilizados arriba. Con los datos de la tabla “Chile_Japon_Polonia.csv”: ¿qué se puede decir sobre la mortalidad de Polonia en los años 1990, 2000 y 2010? Graficar la distribución de las defunciones por edad (colocando cada punto en la edad media del intervalo, por ejemplo para el grupo 5-10, en 7.5). 5.5 Funciones demográficas en paquetes demográficos Estamos entrando en zona de utilización de funciones demográficas de paquetes. Se sugiere que… Proyecto DemoTools. Su instalación demora un poco: library(devtools) install.packages(&quot;rstan&quot;, repos = c(&quot;https://mc-stan.org/r-packages/&quot;, getOption(&quot;repos&quot;))) install_github(&quot;timriffe/DemoTools&quot;) 5.5.1 Tablas de mortalidad Construir una función que produzca una tabla de mortalidad a partir de un set de tasas por edad es un lindo ejercicio de programación demográfica en R. Podés hacer la tuya y luego checkear con DemoTools. Acá para Japón 2010: jpn_2010 &lt;- db %&gt;% filter(Country == &quot;Japon&quot;, Year == 2010) # obtengo la tabla library(DemoTools) tm_jpn_2010 &lt;- lt_abridged(nMx = jpn_2010$M, Age = jpn_2010$Age) # veamos la función de sobrevivencia: tm_jpn_2010 %&gt;% ggplot(aes(Age, lx)) + geom_point() + geom_line()+ theme_bw() 5.5.2 Evaluación de declaración de edad Con el índice de Myers veamos si en Chaco mejoró la declaración por edad de varones entre los censos 2001 y 2010. Un indicador que tienda a 0 indica una mejor declaración (bajo los supuesto del método). pob_chaco &lt;- readxl::read_xlsx(&quot;Data/PoblCensal01y10.xlsx&quot;, sheet=1) %&gt;% filter(PROV_NOMBRE == &quot;CHACO&quot;) pob_chaco %&gt;% ggplot(aes(EDAD, VARON, color=factor(CENSO))) + geom_point() + geom_line() + scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) + theme_bw() # obtengo Myers pob_chaco %&gt;% summarise(Myers_2001 = check_heaping_myers(VARON[CENSO==2001], EDAD[CENSO==2001], ageMin = 20, ageMax = 64), Myers_2010 = check_heaping_myers(VARON[CENSO==2010], EDAD[CENSO==2010], ageMin = 20, ageMax = 64)) 5.5.3 Graduación de población por edad simple El método de Sprague desagrega por edad simple conteos agrupados por edad quinquenal. Veamos como funciona para los varones de Chaco en el año 2010. Primero agregando, y luego aplicando el método. # me quedo con 2010 pob_chaco_2010 &lt;- pob_chaco %&gt;% filter(CENSO == 2010) # agrupo la población por grupos quinquenales pob_chaco_2010_quinquenal &lt;- pob_chaco %&gt;% filter(CENSO == 2010) %&gt;% mutate(EDAD_q = trunc(EDAD/5) * 5) %&gt;% group_by(EDAD_q) %&gt;% summarise(VARON = sum(VARON)) # aplico sprague pob_chaco_2010_sprague &lt;- graduate(pob_chaco_2010_quinquenal$VARON, pob_chaco_2010_quinquenal$EDAD_q, method = &quot;sprague&quot;) # junto pob_chaco_2010_simple &lt;- pob_chaco_2010 %&gt;% full_join(tibble(EDAD = 0:110, VARON_sprague = pob_chaco_2010_sprague)) %&gt;% select(EDAD, VARON, VARON_sprague) %&gt;% pivot_longer(!EDAD, names_to=&quot;Tipo&quot;, values_to=&quot;Población&quot;) # visualizo pob_chaco_2010_simple %&gt;% ggplot(aes(EDAD, Población, color=Tipo)) + geom_line() + geom_point() Para ser más rigurosos en la notación \\(N(t)\\) debería ser expresado como \\(\\overline{N}(t,t+1)\\), pero simplificaremos un poco para enfocarnos en lo que haremos en R. Para más detalles ver Preston y otros (2001)↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
